#pragma kernel CSRaymarch

#include "IBLUtils.hlsl" 
#include "Assets/Part 1/Shaders/SHCommon.hlsl"

RWTexture2D<float4> Result;
TextureCube<float4> _EnvTex;
SamplerState sampler_EnvTex;
StructuredBuffer<float3> _SHCoefficients;

float _Roughness;
float _Metallic;
float4x4 _InvViewMatrix;
float4x4 _InvProjectionMatrix;
float3 _WorldSpaceCameraPos;
float4 _Time;

// --- Constants ---
#define MAX_STEPS 100
#define MAX_DIST 100.0
#define SURF_DIST 0.001

// --- Math & SDFs ---
float3 rotateX(float3 p, float angle)
{
    float s = sin(angle);
    float c = cos(angle);
    return float3(p.x, c * p.y + s * p.z, -s * p.y + c * p.z);
}

float sdSphere(float3 p, float s) { return length(p) - s; }

float sdBox(float3 p, float3 b)
{
    float3 q = abs(p) - b;
    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}

float sdTorus(float3 p, float2 t)
{
    float2 q = float2(length(p.xz) - t.x, p.y);
    return length(q) - t.y;
}

float smin(float a, float b, float k)
{
    k *= 1.0 / (1.0 - sqrt(0.5));
    float h = max(k - abs(a - b), 0.0) / k;
    return min(a, b) - k * 0.5 * (1.0 + h - sqrt(1.0 - h * (h - 2.0)));
}

// --- Scene Logic ---
// --- Scene Logic ---
float map(float3 position)
{
    float time = _Time.y;
    float timeLoop = abs(sin(time)) * .6;
                
    // Scene Positions
    float3 spherePos = float3(0, 0, 5);
    float3 cubePos = float3(2.5, -0.2, 4);
    float3 torusPos = float3(-2.5, 0, 5.5);

    // 1. Torus with Rotation
    float3 pTorus = position - torusPos;
    // Rotate about X axis
    pTorus = rotateX(pTorus, time); 
    float torusDist = sdTorus(pTorus, float2(0.6, 0.2));

    // 2. Sphere and Cube with Smooth Blend
    float3 pSphere = position - spherePos;
    float sphereDist = sdSphere(pSphere, 0.8);

    float3 pCube = position - cubePos;
    float cubeDist = sdBox(pCube, float3(0.7, 0.7, 0.7)); // "size 0.7" usually means half-extent is 0.7 or size is 1.4? 
                                                          // Looking at standard sdBox(p, b), b is half-size (extent).
                                                          // Assuming "size 0.7" means the box extends 0.7 in each direction (half-size).
    
    float blended = smin(sphereDist, cubeDist, timeLoop);

    // Union of the blended group and the torus
    return min(blended, torusDist);
}

float3 getNormal(float3 p)
{
    float2 e = float2(1e-4, 0);
    
    // Finite difference approximation
    return normalize(float3(
        map(p + e.xyy) - map(p - e.xyy),
        map(p + e.yxy) - map(p - e.yxy),
        map(p + e.yyx) - map(p - e.yyx)
    ));
}

float rayMarch(float3 rayOrigin, float3 rayDirection)
{
    float dist = 0.0;

    for (int i = 0; i < MAX_STEPS; i++)
    {
        float3 p = rayOrigin + rayDirection * dist;
        float dS = map(p);
        dist += dS;

        if (dist > MAX_DIST || dS < SURF_DIST) break;
    }
    
    return dist;
}

[numthreads(8, 8, 1)]
void CSRaymarch (uint3 id : SV_DispatchThreadID)
{
    uint width, height;
    Result.GetDimensions(width, height);
    
    uint numberOfLevels = (uint)floor(log2((float)width)) + 1;
    
    if (id.x >= width || id.y >= height) { return; }

    // --- Screen to World Ray ---
    float2 uv = float2((id.xy + 0.5) / float2(width, height) * 2.0 - 1.0);
    float4 clipPos = float4(uv, 0, 1);
    float4 viewPos = mul(_InvProjectionMatrix, clipPos);
    viewPos /= viewPos.w;
    float3 rayDirection = normalize(mul((float3x3)_InvViewMatrix, viewPos.xyz));
    float3 rayOrigin = _WorldSpaceCameraPos;

    // --- Rendering ---
    float dist = rayMarch(rayOrigin, rayDirection);
    float3 finalColor = float3(0, 0, 0);

    if (dist < MAX_DIST)
    {
        float3 position = rayOrigin + rayDirection * dist;
        float3 normal = getNormal(position);
        float3 reflectDir = reflect(rayDirection, normal);
        float cosTheta = max(dot(normal, reflectDir), 0.0);

        float rough = _Roughness + 1e-4;
        float perceptualRoughness = rough * rough;
        float3 F0 = lerp(float3(0.04, 0.04, 0.04), float3(1, 1, 1), _Metallic);
        
        float3 F = fresnelSchlickRoughness(cosTheta, F0, rough);
        float3 kD = (1.0 - F) * (1.0 - _Metallic);

        float3 specularBRDF = EnvironmentBRDF(perceptualRoughness, cosTheta, F0);
        float3 prefilteredColor = _EnvTex.SampleLevel(sampler_EnvTex, reflectDir, perceptualRoughness * numberOfLevels).rgb;
        
        finalColor = (kD * RenderSHLighting(normal, _SHCoefficients)) + (prefilteredColor * specularBRDF);
    }
    else
    {
        finalColor = _EnvTex.SampleLevel(sampler_EnvTex, rayDirection, 0).rgb;
    }

    Result[id.xy] = float4(finalColor, 1.0);
}